## Everything in this file gets sourced during `simInit()`,
## and all functions and objects are put into the `simList`.
## To use objects, use `sim$xxx` (they are globally available to all modules).
## Functions can be used without `sim$` as they are namespaced to the module,
## just like functions in R packages.
## If exact location is required, functions will be: `sim$<moduleName>$FunctionName`.
defineModule(sim, list(
  name = "assistedMigrationBC",
  description = "assisted migration in British Columbia - very idiosyncratic",
  keywords = "genetics",
  authors = structure(list(list(given = c("Ian"), family = "Eddy", role = c("aut", "cre"), email = "ian.eddy@canada.com", comment = NULL)), class = "person"),
  childModules = character(0),
  version = list(SpaDES.core = "1.0.0.9000", assistedMigrationBC = "0.0.0.9000"),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = deparse(list("README.txt", "assistedMigrationBC.Rmd")),
  reqdPkgs = list('data.table', 'magrittr', 'raster'),
  parameters = rbind(
    #defineParameter("paramName", "paramClass", value, min, max, "parameter description"),
    defineParameter(".plotInitialTime", "numeric", NA, NA, NA,
                    "Describes the simulation time at which the first plot event should occur."),
    defineParameter(".plotInterval", "numeric", NA, NA, NA,
                    "Describes the simulation time interval between plot events."),
    defineParameter(".saveInitialTime", "numeric", NA, NA, NA,
                    "Describes the simulation time at which the first save event should occur."),
    defineParameter(".saveInterval", "numeric", NA, NA, NA,
                    "This describes the simulation time interval between save events."),
    defineParameter(".useCache", "logical", FALSE, NA, NA,
                    paste("Should this entire module be run with caching activated?",
                          "This is generally intended for data-type modules, where stochasticity",
                          "and time are not relevant")),
    defineParameter("cohortDefinitionCols", "character", c("pixelGroup", "speciesCode", "age", "Provenance", "Planted"),
                    NA, NA, desc = paste("`cohortData` columns that determine what constitutes a cohort.",
                                         "This module only uses the param for assertions")),
    defineParameter("doAssistedMigration", 'logical', TRUE, NA, NA,
                    "if TRUE, provenance table is updated at 2020, 2050, and 2080"),
    defineParameter("landscapeSummaryTime", "numeric", 10, NA, NA,
                    desc = "how often to save object with every planted cohort"),
    defineParameter("optimizeProvenanceTable", 'logical', TRUE, NA, NA, 'if FALSE, will only plant what is present'),
    defineParameter("sppEquivCol", "character", "Boreal", NA, NA,
                    "The column in sim$specieEquivalency data.table to use as a naming convention"),
    defineParameter("trackGeneticModifier", "logical", TRUE, NA, NA,
                    "if TRUE, will remove the genetic modifier column if present, every year, as clean up of cohortData")
  ),
  inputObjects = bind_rows(
    #expectsInput("objectName", "objectClass", "input object description", sourceURL, ...),
    expectsInput("BECkey", 'data.table', desc = "key that contains the raster ID and corresponding zone/subzone/var of projected BECs",
                 sourceURL = "https://drive.google.com/open?id=1v4_ZSXFAopYrTPpapxB3cHAIJJLE0sX0"),
    expectsInput("cohortData", "data.table",
                 desc = "Columns: B, pixelGroup, speciesCode, Indicating several features about ages and current vegetation of stand"),
    expectsInput("sppEquiv", "data.table",
                 desc = "table of species equivalencies. See LandR::sppEquivalencies_CA.",
                 sourceURL = ""),
    expectsInput("transferTable", 'data.table',
                 desc = "table of transfer functions representing climate-sensitive genetic growth - from Greg O'Neil",
                 sourceURL = 'https://drive.google.com/open?id=1N0VrvdgtzQLzlVhMYAg-xKPVLcxOZTSe'),
    expectsInput("projectedBEC", "RasterStack",
                 desc = "the projected BEC zones; already reclassified to ensure consistent raster representation",
                 sourceURL = 'https://drive.google.com/open?id=1SJf9zQqBcznw5uByfRZ5ulk2ktfHia26'),
    expectsInput('ecoregionMap', "RasterLayer",
                 desc = paste("a map of ecoregions with corresponding RAT that contains the BEC code of each ecoregion.",
                               'This must be generated by Biomass_borealDataPrep using projectedBEC$BECref as ecoregion')),
    expectsInput("pixelGroupMap", "RasterLayer", desc = 'raster with locations of pixel groups'),
    expectsInput('sppEquiv', objectClass = 'data.table', desc = 'sppEquivalencies table. See LandR::sppEquivalencies_CA')
  ),
  outputObjects = bind_rows(
    #createsOutput("objectName", "objectClass", "output object description", ...),
    createsOutput(objectName = 'provenanceTable', objectClass = 'data.table',
                  desc = 'a table that dictates what species are planted at what locations. Has columns ecoregionGroup, species, provenance'),
    createsOutput(objectName = "currentBEC", objectClass = 'RasterLayer', desc = "the projected BEC zones at time(sim)"),
    createsOutput(objectName = "plantedCohorts", objectClass = 'data.table', desc = "planted cohort summary")
  )
))

## event types
#   - type `init` is required for initialization

doEvent.assistedMigrationBC = function(sim, eventTime, eventType) {
  switch(
    eventType,
    init = {
      ### check for more detailed object dependencies:
      ### (use `checkObject` or similar)

      # do stuff for this event
      sim <- Init(sim)

      # schedule future event(s)
      sim <- scheduleEvent(sim, start(sim), 'assistedMigrationBC', 'assignProvenance', eventPriority = 5.5)
      sim <- scheduleEvent(sim, P(sim)$.plotInitialTime, "assistedMigrationBC", "plot")
      sim <- scheduleEvent(sim, P(sim)$.saveInitialTime, "assistedMigrationBC", "save")
      sim <- scheduleEvent(sim, 2020, 'assistedMigrationBC', 'updateProvenanceTable', eventPriority = 1)
      sim <- scheduleEvent(sim, 2050, 'assistedMigrationBC', 'updateProvenanceTable', eventPriority = 1)
      sim <- scheduleEvent(sim, 2080, 'assistedMigrationBC', 'updateProvenanceTable', eventPriority = 1)
      sim <- scheduleEvent(sim, end(sim), 'assistedMigrationBC', 'assignProvenance', eventPriority = 5.5)
      if (!is.na(P(sim)$landscapeSummaryTime)) {
        sim <- scheduleEvent(sim, start(sim), 'assistedMigrationBC', 'landscapeSummary', eventPriority = 9)
      }
    },

    assignProvenance = {
      if (P(sim)$trackGeneticModifier) {
        #this column must be dropped every year as it is added by LandRCSAM in mortalityAndGrowth event.
        if (!is.null(sim$cohortData$HTp_pred)){
          sim$cohortData[, HTp_pred := NULL]
        }
      }

      if (is.null(sim$cohortData$Provenance) | any(is.na(sim$cohortData$Provenance))) {
        oldCohortData <- copy(sim$cohortData)
        sim$cohortData <- assignProvenance(cohortData = sim$cohortData,
                                           ecoregionMap = sim$ecoregionMap,
                                           BECkey = sim$BECkey, time = time(sim),
                                           cohortDefinitionCols = P(sim)$cohortDefinitionCols)
        if (nrow(sim$cohortData) != nrow(oldCohortData)) {
          #this is only temporary until I am sure rows are dropped or introduced
          warning("before assigning provenance, cohortData had ", oldNrow, " rows - ",
                  "it now has ", nrow(sim$cohortData), "rows")
          #this occured once, in 2067 -
          #incorrect RHJ of CD to Ecoregions, when all EFFSvm ecoregions were replaced by planted cohorts
          #I believe it is no longer necessayr but will retain it as an alternative to more assertions
          oldCohortData[, nCohorts := .N, .(pixelGroup)]
          newCohortData <- copy(sim$cohortData)
          newCohortData[, nCohorts := .N, .(pixelGroup)]
          diffCohort <- oldCohortData[!newCohortData, on = c("pixelGroup", "nCohorts")]
          write.csv(diffCohort, paste0("scratch/", "diffCohort", time(sim), ".csv"))
        }

        assertCohortData(cohortData = sim$cohortData, pixelGroupMap = sim$pixelGroupMap,
                         cohortDefinitionCols = P(sim)$cohortDefinitionCols)
        #this is post-dispersal, but before growth and mortality
      }
      sim <- scheduleEvent(sim, time(sim) + 1, 'assistedMigrationBC', 'assignProvenance', eventPriority = 5.5)
    },
    updateProvenanceTable = {
      sim$currentBEC <- sim$projectedBEC[[grep(pattern = paste0('*', time(sim)), value = TRUE, x = names(sim$projectedBEC))]]
      if (P(sim)$doAssistedMigration){
        sim$provenanceTable <- generateBCProvenanceTable(transferTable = sim$transferTable,
                                                         BECkey = sim$BECkey,
                                                         projectedBEC = sim$currentBEC,
                                                         ecoregionMap = sim$ecoregionMap,
                                                         sppEquiv = sim$sppEquiv,
                                                         sppEquivCol = P(sim)$sppEquivCol)
      }

    },
    landscapeSummary = {
      plantedCohorts <- sim$cohortData[planted == TRUE,]
      if (!is.null(sim$plantedCohorts)){
        sim$plantedCohorts <- rbind(sim$plantedCohorts, plantedCohorts, fill = TRUE)
      } else {
        sim$plantedCohorts <- plantedCohorts
      }
      sim <- scheduleEvent(sim, time(sim) + P(sim)$landscapeSummaryTime, 'assistedMigrationBC', 'landscapeSummary', eventPriority = 8)
    },

    warning(paste("Undefined event type: \'", current(sim)[1, "eventType", with = FALSE],
                  "\' in module \'", current(sim)[1, "moduleName", with = FALSE], "\'", sep = ""))
  )
  return(invisible(sim))
}

### template initialization
Init <- function(sim) {

  if (time(sim) < 2020) {
    sim$currentBEC <- sim$projectedBEC$BECref
  } else if (time(sim) < 2050) {
    sim$currentBEC <- sim$projectedBEC$BEC2020
  } else if (time(sim) < 2080) {
    sim$currentBEC <- sim$projectedBEC$BEC2050
  } else {
    sim$currentBEC <- sim$projectedBEC$BEC2080
  }

  joinCol <- c('BC_Forestry', eval(P(sim)$sppEquivCol))
  sppEquivSubset <- sim$sppEquiv[, .SD, .SDcols = joinCol]

  sim$transferTable <- sim$transferTable[sppEquivSubset, on = c("species" = "BC_Forestry")]
  sim$transferTable[, species := NULL]
  setnames(sim$transferTable, eval(P(sim)$sppEquivCol), 'speciesCode')

  if (P(sim)$optimizeProvenanceTable) {
  sim$provenanceTable <- generateBCProvenanceTable(transferTable = sim$transferTable,
                                                   BECkey = sim$BECkey,
                                                   projectedBEC = sim$projectedBEC$BECref,
                                                   ecoregionMap = sim$ecoregionMap,
                                                   sppEquiv = sim$sppEquiv,
                                                   sppEquivCol = P(sim)$sppEquivCol)
  } else {
    sim$provenanceTable <- generateBCProvenanceTable(transferTable = sim$transferTable,
                                                     BECkey = sim$BECkey,
                                                     projectedBEC = sim$projectedBEC$BECref,
                                                     ecoregionMap = sim$ecoregionMap,
                                                     sppEquiv = sim$sppEquiv,
                                                     sppEquivCol = P(sim)$sppEquivCol,
                                                     method = 'noOptimization')
    #this could obviously be combined into one function call - todo later.
  }

  #assign provenance as it is part of cohortDefinitionCols
  if (is.null(sim$cohortData$Provenance) | any(is.na(sim$cohortData$Provenance))) {
    sim$cohortData <- assignProvenance(cohortData = sim$cohortData,
                                       ecoregionMap = sim$ecoregionMap,
                                       BECkey = sim$BECkey, time = time(sim),
                                       cohortDefinitionCols = P(sim)$cohortDefinitionCols)
  }

  return(invisible(sim))
}

assignProvenance <- function(cohortData, ecoregionMap, BECkey, time = time(sim), cohortDefinitionCols) {
  cohortCols <- colnames(cohortData)
  cohortData <- copy(cohortData)
  BECkey <- copy(BECkey)
  ecoregionKey <- as.data.table(ecoregionMap@data@attributes[[1]])
  setnames(ecoregionKey, 'ID', 'ecoregionMapCode') #Change ID, because ID in BECkey = ecoregion, not mapcode
  pLength <- max(nchar(as.character(ecoregionKey$ecoregion)))
  BECkey[, ID := as.factor(paddedFloatToChar(ID, padL = pLength))]

  ecoregionKey <- BECkey[ecoregionKey, on = c("ID" = 'ecoregion')] #now we have zsv of cohortData$ecoregionGroup
  ecoregionKeySmall <- ecoregionKey[, .(zsv, ecoregionGroup)]

  if (is.null(cohortData$Provenance)){
    cohortData <- ecoregionKeySmall[cohortData, on = c("ecoregionGroup" = 'ecoregionGroup')]
    setnames(cohortData, 'zsv', 'Provenance')
    setcolorder(cohortData, c(cohortCols, 'Provenance'))
  } else {
    cohortData <- ecoregionKeySmall[cohortData, on = c("ecoregionGroup" = 'ecoregionGroup')]
    setnames(cohortData, 'zsv', 'assumedProvenance')
    suppressWarnings(cohortData[is.na(Provenance), Provenance := assumedProvenance])
    cohortData[, assumedProvenance := NULL]
    setcolorder(cohortData, cohortCols)
  }

  #there should be no duplicates - but the only way to confirm is to parameterize with cohortDefinitionCols
  anyDuplicates <- duplicated(cohortData[, .SD, .SDcol = cohortDefinitionCols])
  if (any(anyDuplicates)){
    warning("duplicate cohorts detected after assigning Provenance - review")
  }

  return(cohortData)
}

.inputObjects <- function(sim) {

  cacheTags <- c(currentModule(sim), "function:.inputObjects") ## uncomment this if Cache is being used
  dPath <- asPath(getOption("reproducible.destinationPath", dataPath(sim)), 1)
  message(currentModule(sim), ": using dataPath '", dPath, "'.")

  # ! ----- EDIT BELOW ----- ! #
  if (!suppliedElsewhere("BECkey", sim)) {
    sim$BECkey <- prepInputs(url = extractURL('BECkey', sim),
                             destinationPath = dPath,
                             fun = 'read.csv', useCache = FALSE,
                             overwrite = TRUE,
                             userTags = c(cacheTags, 'BECkey'))
    sim$BECkey <- as.data.table(sim$BECkey) %>%
      .[, X := NULL] %>%
      .[ID != 14] #variant with ID 14 was combined with 12 in the raster map,
    #must be excluded else cartesian join issues... it was incorrecty renamed instead of being removed entirely
  }


  if (!suppliedElsewhere("transferTable", sim)) {

    transferTable <- prepInputs(url = extractURL('transferTable', sim), destinationPath = dPath,
                                targetFile = "GregONeilData_Formatted.csv",
                                userTags = c(cacheTags, 'transferTable'),
                                fun = 'read.csv')
    transferTable <- as.data.table(transferTable) %>% #don't fread, it is too much of a hassle with cache
      .[, X := NULL]
    sim$transferTable <- transferTable

  }

  if (!suppliedElsewhere("cohortData", sim)) {
    stop("This module needs cohortData. Please run one of Biomass_core or Biomass_borealDataPrep or contact authors")
  }

  if (!suppliedElsewhere("projectedBEC", sim)) {

    sim$projectedBEC <- prepInputs(targetFile = 'reclassifiedBECs.grd',
                                   url = extractURL("projectedBEC", sim),
                                   filename2 = NULL,
                                   destinationPath = dPath,
                                   fun = "raster::stack",
                                   alsoExtract = 'reclassifiedBECs.gri',
                                   studyArea = sim$studyArea,
                                   rasterToMatch = sim$rasterToMatch,
                                   method = 'ngb',
                                   overwrite = TRUE,
                                   userTags = c(cacheTags, 'flyingBECs')) #assume we only need these for studyArea!
    names(sim$projectedBEC) <- c("BECref", "BEC2020", "BEC2050", "BEC2080")
    NAvalue(sim$projectedBEC) <- 0 #this should have been set before uploading to Google

  }

  # ! ----- STOP EDITING ----- ! #
  return(invisible(sim))
}

### add additional events as needed by copy/pasting from above
