## Everything in this file gets sourced during `simInit()`,
## and all functions and objects are put into the `simList`.
## To use objects, use `sim$xxx` (they are globally available to all modules).
## Functions can be used without `sim$` as they are namespaced to the module,
## just like functions in R packages.
## If exact location is required, functions will be: `sim$<moduleName>$FunctionName`.
defineModule(sim, list(
  name = "assistedMigrationBC",
  description = "",
  keywords = "",
  authors = structure(list(list(given = c("Ian"), family = "Eddy", role = c("aut", "cre"), email = "ian.eddy@canada.com", comment = NULL)), class = "person"),
  childModules = character(0),
  version = list(SpaDES.core = "1.0.0.9000", assistedMigrationBC = "0.0.0.9000"),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = deparse(list("README.txt", "assistedMigrationBC.Rmd")),
  reqdPkgs = list('data.table', 'magrittr', 'raster'),
  parameters = rbind(
    #defineParameter("paramName", "paramClass", value, min, max, "parameter description"),
    defineParameter(".plotInitialTime", "numeric", NA, NA, NA,
                    "Describes the simulation time at which the first plot event should occur."),
    defineParameter(".plotInterval", "numeric", NA, NA, NA,
                    "Describes the simulation time interval between plot events."),
    defineParameter(".saveInitialTime", "numeric", NA, NA, NA,
                    "Describes the simulation time at which the first save event should occur."),
    defineParameter(".saveInterval", "numeric", NA, NA, NA,
                    "This describes the simulation time interval between save events."),
    defineParameter(".useCache", "logical", FALSE, NA, NA,
                    paste("Should this entire module be run with caching activated?",
                          "This is generally intended for data-type modules, where stochasticity",
                          "and time are not relevant")),
    defineParameter("sppEquivCol", "character", "Boreal", NA, NA,
                    "The column in sim$specieEquivalency data.table to use as a naming convention"),
    defineParameter("doAssistedMigration", 'logical', TRUE, NA, NA,
                    "if TRUE, provenance table is updated at 2020, 2050, and 2080"),
    defineParameter("trackHarvest", 'logical', FALSE, NA, NA, 'if true, adds column to cohortData for tracking harvest')
  ),
  inputObjects = bind_rows(
    #expectsInput("objectName", "objectClass", "input object description", sourceURL, ...),
    expectsInput("BECkey", 'data.table', desc = "key that contains the raster ID and corresponding zone/subzone/var of projected BECs",
                 sourceURL = "https://drive.google.com/open?id=1v4_ZSXFAopYrTPpapxB3cHAIJJLE0sX0"),
    expectsInput("cohortData", "data.table",
                 desc = "Columns: B, pixelGroup, speciesCode, Indicating several features about ages and current vegetation of stand"),
    expectsInput("sppEquiv", "data.table",
                 desc = "table of species equivalencies. See LandR::sppEquivalencies_CA.",
                 sourceURL = ""),
    expectsInput("transferTable", 'data.table',
                 desc = "table of transfer functions representing climate-sensitive genetic growth - from Greg O'Neil",
                 sourceURL = 'https://drive.google.com/open?id=1N0VrvdgtzQLzlVhMYAg-xKPVLcxOZTSe'),
    expectsInput("projectedBEC", "rasterStack",
                 desc = "the projected BEC zones; already reclassified to ensure consistent raster representation",
                 sourceURL = 'https://drive.google.com/open?id=1SJf9zQqBcznw5uByfRZ5ulk2ktfHia26'),
    expectsInput('ecoregionMap', "rasterLayer",
                 desc = paste("a map of ecoregions with corresponding RAT that contains the BEC code of each ecoregion.",
                               'This must be generated by running Biomass_borealDataPrep with the projectedBEC$BECref as ecoregion')),
    expectsInput('sppEquiv', objectClass = 'data.table', desc = 'sppEquivalencies table. See LandR::sppEquivalencies_CA')
  ),
  outputObjects = bind_rows(
    #createsOutput("objectName", "objectClass", "output object description", ...),
    createsOutput(objectName = 'provenanceTable', objectClass = 'data.table',
                  desc = 'a table that dictates what species are planted at what locations. Has columns ecoregionGroup, species, provenance'),
    createsOutput(objectName = "currentBEC", objectClass = 'RasterLayer', desc = "the projected BEC zones at time(sim)")
  )
))

## event types
#   - type `init` is required for initialization

doEvent.assistedMigrationBC = function(sim, eventTime, eventType) {
  switch(
    eventType,
    init = {
      ### check for more detailed object dependencies:
      ### (use `checkObject` or similar)

      # do stuff for this event
      sim <- Init(sim)

      # schedule future event(s)
      sim <- scheduleEvent(sim, start(sim), 'assistedMigrationBC', 'assignProvenance', eventPriority = 5.5)
      sim <- scheduleEvent(sim, P(sim)$.plotInitialTime, "assistedMigrationBC", "plot")
      sim <- scheduleEvent(sim, P(sim)$.saveInitialTime, "assistedMigrationBC", "save")
      sim <- scheduleEvent(sim, 2020, 'assistedMigrationBC', 'updateProvenanceTable', eventPriority = 1)
      sim <- scheduleEvent(sim, 2050, 'assistedMigrationBC', 'updateProvenanceTable', eventPriority = 1)
      sim <- scheduleEvent(sim, 2080, 'assistedMigrationBC', 'updateProvenanceTable', eventPriority = 1)
      sim <- scheduleEvent(sim, end(sim), 'assistedMigrationBC', 'assignProvenance', eventPriority = 5.5)
      #as sim may end with dispersal event, leaving some provenances undefined

    },

    assignProvenance = {

      if (is.null(sim$cohortData$Provenance) | any(is.na(sim$cohortData$Provenance))) {
        sim$cohortData <- assignProvenance(cohortData = sim$cohortData,
                                           ecoregionMap = sim$ecoregionMap,
                                           BECkey = sim$BECkey)
      }
      sim <- scheduleEvent(sim, time(sim) + 1, 'assistedMigrationBC', 'assignProvenance', eventPriority = 5.5)
      #this is post-dispersal, but before growth and mortality
    },
    updateProvenanceTable = {

      # ! ----- EDIT BELOW ----- ! #
      sim$currentBEC <- sim$projectedBEC[[grep(pattern = paste0('*', time(sim)), value = TRUE, x = names(sim$projectedBEC))]]

      if (P(sim)$doAssistedMigration){
        sim$provenanceTable <- generateBCProvenanceTable(transferTable = sim$transferTable,
                                                         BECkey = sim$BECkey,
                                                         projectedBEC = sim$currentBEC,
                                                         ecoregionMap = sim$ecoregionMap,
                                                         sppEquiv = sim$sppEquiv,
                                                         sppEquivCol = P(sim)$sppEquivCol)
      }

    },
    warning(paste("Undefined event type: \'", current(sim)[1, "eventType", with = FALSE],
                  "\' in module \'", current(sim)[1, "moduleName", with = FALSE], "\'", sep = ""))
  )
  return(invisible(sim))
}

## event functions
#   - keep event functions short and clean, modularize by calling subroutines from section below.

### template initialization
Init <- function(sim) {

  if (time(sim) < 2020) {
    sim$currentBEC <- sim$projectedBEC$BECref
  } else if (time(sim) < 2050) {
    sim$currentBEC <- sim$projectedBEC$BEC2020
  } else if (time(sim) < 2080) {
    sim$currentBEC <- sim$projectedBEC$BEC2050
  } else {
    sim$currentBEC <- siM$projectedBEC$BEC2080
  }

  joinCol <- c('BC_Forestry', eval(P(sim)$sppEquivCol))
  sppEquivSubset <- sim$sppEquiv[, .SD, .SDcols = joinCol]

  sim$transferTable <- sim$transferTable[sppEquivSubset, on = c("species" = "BC_Forestry")]
  sim$transferTable[, species := NULL]
  setnames(sim$transferTable, eval(P(sim)$sppEquivCol), 'speciesCode')

  sim$provenanceTable <- generateBCProvenanceTable(transferTable = sim$transferTable,
                                                   BECkey = sim$BECkey,
                                                   projectedBEC = sim$projectedBEC$BECref,
                                                   ecoregionMap = sim$ecoregionMap,
                                                   sppEquiv = sim$sppEquiv,
                                                   sppEquivCol = P(sim)$sppEquivCol)

  #fixes species column - this could be done in a function - it is done anyway in generateBCProvenanceTable
 if (P(sim)$trackHarvest) {
   #assume nothing is harvested at start(sim)
   sim$cohortData[, harvested := NA]
 }


  return(invisible(sim))
}

assignProvenance <- function(cohortData, ecoregionMap, BECkey) {

  cohortCols <- colnames(cohortData)
  cohortData <- copy(cohortData)
  BECkey <- copy(BECkey)
  ecoregionKey <- as.data.table(ecoregionMap@data@attributes[[1]])
  setnames(ecoregionKey, 'ID', 'ecoregionMapCode') #Change ID, because ID in BECkey = ecoregion, not mapcode
  BECkey[, ID := as.factor(paddedFloatToChar(ID, padL = 2))]

  ecoregionKey <- BECkey[ecoregionKey, on = c("ID" = 'ecoregion')] #now we have zsv of cohortData$ecoregionGroup
  ecoregionKeySmall <- ecoregionKey[, .(zsv, ecoregionGroup)]

  if (is.null(cohortData$Provenance)){
    cohortData <- ecoregionKeySmall[cohortData, on = c("ecoregionGroup" = 'ecoregionGroup')]
    setnames(cohortData, 'zsv', 'Provenance')
    setcolorder(cohortData, c(cohortCols, 'Provenance'))
  } else {
    cohortData <- cohortData[ecoregionKeySmall, on = c("ecoregionGroup" = 'ecoregionGroup')]
    setnames(cohortData, 'zsv', 'assumedProvenance')
    cohortData[is.na(Provenance), Provenance := assumedProvenance]
    cohortData[, assumedProvenance := NULL]
    setcolorder(cohortData, cohortCols)
  }

  anyDuplicates <- duplicated(cohortData[, .(pixelGroup, Provenance, age, speciesCode)])
  if (any(anyDuplicates)){
    #This occurs when a formerly NA cohort is assigned a provenance and becomes NA. Should only happen after dispersal.
    #code lifted from biomass_core. I haven't really figured this one out.
    tdDuplicates <- cohortData[cohortData[anyDuplicates], nomatch = NULL,
                               on = c("pixelGroup", "age", 'Provenance', 'speciesCode'), which = TRUE]
    td <- cohortData[tdDuplicates]
    td <- td[, .(ecoregionGroup = unique(ecoregionGroup),
                 B = sum(B, na.rm = TRUE),
                 mortality = sum(mortality, na.rm = TRUE),
                 aNPPAct = sum(aNPPAct, na.rm = TRUE)),
             by = c("pixelGroup", 'speciesCode', 'age', 'Provenance')]
    cdColNames <- intersect(colnames(cohortData), colnames(td))
    td <- td[, ..cdColNames] # keep only the columns, in the correct order, as cohortData
    tdNonDups <- cohortData[-tdDuplicates]
    cohortData <- rbindlist(list(td, tdNonDups), fill = TRUE)
  }


  return(cohortData)
}

.inputObjects <- function(sim) {

  cacheTags <- c(currentModule(sim), "function:.inputObjects") ## uncomment this if Cache is being used
  dPath <- asPath(getOption("reproducible.destinationPath", dataPath(sim)), 1)
  message(currentModule(sim), ": using dataPath '", dPath, "'.")

  # ! ----- EDIT BELOW ----- ! #
  if (!suppliedElsewhere("BECkey", sim)) {
    sim$BECkey <- prepInputs(url = extractURL('BECkey', sim),
                             destinationPath = dPath,
                             fun = 'read.csv', useCache = FALSE,
                             overwrite = TRUE,
                             userTags = c(cacheTags, 'BECkey'))
    sim$BECkey <- as.data.table(sim$BECkey) %>%
      .[, X := NULL] %>%
      .[ID != 14] #variant with ID 14 was combined with 12 in the raster map,
    #must be excluded else cartesian join issues... it was incorrecty renamed instead of being removed entirely
  }


  if (!suppliedElsewhere("transferTable", sim)) {

    transferTable <- prepInputs(url = extractURL('transferTable', sim), destinationPath = dPath,
                                targetFile = "GregONeilData_Formatted.csv",
                                userTags = c(cacheTags, 'transferTable'),
                                fun = 'read.csv')
    transferTable <- as.data.table(transferTable) %>% #don't fread, it is too much of a hassle with cache
      .[, X := NULL]
    sim$transferTable <- transferTable

  }

  if (!suppliedElsewhere("cohortData", sim)) {
    stop("This module needs cohortData. Please run one of Biomass_core or Biomass_borealDataPrep or contact authors")
  }

  if (!suppliedElsewhere("projectedBEC", sim)) {

    sim$projectedBEC <- prepInputs(targetFile = 'reclassifiedBECs.grd',
                                   url = extractURL("projectedBEC", sim),
                                   filename2 = NULL,
                                   destinationPath = dPath,
                                   fun = "raster::stack",
                                   alsoExtract = 'reclassifiedBECs.gri',
                                   studyArea = sim$studyArea,
                                   rasterToMatch = sim$rasterToMatch,
                                   method = 'ngb',
                                   overwrite = TRUE,
                                   userTags = c(cacheTags, 'flyingBECs')) #assume we only need these for studyArea!
    names(sim$projectedBEC) <- c("BECref", "BEC2020", "BEC2050", "BEC2080")
    NAvalue(sim$projectedBEC) <- 0 #this should have been set before uploading to Google

  }

  # ! ----- STOP EDITING ----- ! #
  return(invisible(sim))
}

### add additional events as needed by copy/pasting from above
